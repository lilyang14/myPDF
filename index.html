<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>作品集</title>
  
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon_io/favicon-16x16.png">
  <link rel="manifest" href="/favicon_io/site.webmanifest">
  <link rel="shortcut icon" href="/favicon_io/favicon.ico" type="image/x-icon">

  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">

  <style>
    /* -------------------- 基础与布局样式 -------------------- */
    :root { --bg: #1C1C1C; }
    html, body {
      height: 100%; margin: 0; background: var(--bg); color: #fff;
      -webkit-font-smoothing: antialiased; user-select: none;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
    .wrap { padding-top: 60px; min-height: 100vh; box-sizing: border-box; }
    .gallery { width: 100%; max-width: 1200px; margin: 0 auto; }
    
    /* -------------------- 图片容器与加载态 (Skeleton Loading) -------------------- */
    .gallery-item {
      width: 100%;
      min-height: 400px; /* 骨架屏最小高度 */
      background-color: #2e2e2e; /* 骨架屏背景色 */
      position: relative;
      margin-bottom: 20px;
      overflow: hidden;
      border-radius: 8px;
      /* 初始加载动画 */
      animation: skeletonPulse 1.5s infinite linear;
    }
    /* 隐藏图片，等待加载完成 */
    .gallery-item img {
      width: 100%; height: auto; display: block;
      -webkit-user-drag: none; user-drag: none;
      opacity: 0; 
      transition: opacity 0.4s ease-in; /* 平滑淡入 */
    }
    /* 图片加载完成后，移除骨架屏背景和动画，并显示图片 */
    .gallery-item.loaded {
      background-color: transparent;
      animation: none;
      min-height: auto;
    }
    .gallery-item.loaded img {
      opacity: 1; 
    }

    /* 骨架屏脉冲动画 */
    @keyframes skeletonPulse {
      0% { background-color: #2e2e2e; }
      50% { background-color: #383838; }
      100% { background-color: #2e2e2e; }
    }


    /* -------------------- 网络异常提示 (毛玻璃美化版) -------------------- */
    .overlay {
      position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
      background: rgba(0, 0, 0, 0.75); backdrop-filter: blur(8px);
      z-index: 9999; color: #fff; text-align: center;
      visibility: hidden; opacity: 0; transition: 0.3s;
    }
    .overlay.show { visibility: visible; opacity: 1; }
    
    .overlay .card {
      width: 90%; max-width: 380px; padding: 40px 30px;
      background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 24px; box-shadow: 0 20px 40px rgba(0,0,0,0.4);
      display: flex; flex-direction: column; align-items: center;
    }
    .reload-btn {
      padding: 0 32px; height: 46px; border-radius: 999px;
      background: #FFF; color: #000; font-weight: 600; border: none; cursor: pointer;
      transition: all 0.2s; box-shadow: 0 4px 12px rgba(255,255,255,0.15); outline: none;
    }
    .reload-btn:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(255,255,255,0.3); }

    /* -------------------- 响应式设计 -------------------- */
    @media (min-width: 900px) { .gallery { width: 65vw; } }
  </style>
</head>
<body>
  <div class="wrap">
    <main class="gallery" id="gallery" aria-live="polite"></main>
  </div>

  <div class="overlay" id="overlay" role="alertdialog" aria-hidden="true">
    <div class="card">
      <svg class="overlay-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
      </svg>
      <h2 id="overlay-msg">加载遇到问题</h2>
      <p>网络连接似乎有些不稳定<br>请检查连接后点击按钮重试</p>
      <button class="reload-btn" id="reloadBtn" type="button">重新加载页面</button>
    </div>
  </div>

  <script>
    
    // ==================== A. 配置常量 (CONFIG) ====================
    const CONFIG = {
      maxIndex: 5000,
      stopThreshold: 6,
      concurrency: 5,
      exts: ['.png', '.jpg', '.jpeg', '.webp']
    };

    // ==================== B. 状态变量 (STATE) ====================
    const state = {
      currentIndex: 1,      // 下一个要发射请求的图片序号
      renderIndex: 1,       // 当前等待被添加到 DOM 的图片序号 (顺序控制)
      failCount: 0,
      activeRequests: 0,
      buffer: {},           // 结果缓存区 { index: containerElement|null }
      isStopped: false
    };

    // ==================== C. DOM 元素引用 (ELS) ====================
    const els = {
      gallery: document.getElementById('gallery'),
      overlay: document.getElementById('overlay'),
      msg: document.getElementById('overlay-msg'),
      btn: document.getElementById('reloadBtn')
    };

    // ==================== D. 初始化与事件监听 ====================
    window.onload = () => { 
        window.scrollTo(0,0); 
        setupProtection();
        startLoading(); 
    };
    els.btn.onclick = () => location.reload();

    // ==================== E. 核心加载逻辑 (并发与顺序控制) ====================
    
    /** 启动或维持并发加载进程 */
    function startLoading() {
      while (!state.isStopped && state.activeRequests < CONFIG.concurrency) {
        processIndex(state.currentIndex++);
      }
    }

    /** 处理单个序号的图片查找和下载 (异步) */
    async function processIndex(idx) {
      if (idx > CONFIG.maxIndex) return;
      
      state.activeRequests++;
      let container = null;

      for (let ext of CONFIG.exts) {
        const path = `images/work${idx}${ext}`;
        const res = await testImage(path);
        if (res) {
          // 找到图片后，创建包含骨架屏的容器
          container = createImgContainer(path);
          break;
        }
      }

      state.activeRequests--;
      handleResult(idx, container);
      
      startLoading();
    }

    /** 处理下载结果，并按顺序渲染到DOM */
    function handleResult(idx, containerElement) {
      state.buffer[idx] = containerElement; // 存入容器 (或 null)

      while (state.buffer.hasOwnProperty(state.renderIndex)) {
        const currentContainer = state.buffer[state.renderIndex];
        
        if (currentContainer) {
          state.failCount = 0;
          els.gallery.appendChild(currentContainer);
        } else {
          state.failCount++;
        }

        delete state.buffer[state.renderIndex];
        state.renderIndex++;

        // 检查停止条件
        if (state.failCount >= CONFIG.stopThreshold) {
          state.isStopped = true;
          if (els.gallery.children.length === 0) {
              showOverlay('未找到任何作品');
          }
          return;
        }
      }
    }

    // ==================== F. 辅助功能函数 ====================
    
    /**
     * 创建图片容器 (包含加载状态逻辑)。
     */
    function createImgContainer(src) {
      const itemContainer = document.createElement('div');
      itemContainer.className = 'gallery-item';

      const img = document.createElement('img');
      img.src = src;
      img.loading = els.gallery.children.length < 3 ? 'eager' : 'lazy';

      // **关键加载状态逻辑**：图片加载完成后，添加 'loaded' 类以显示图片并移除骨架屏动画
      img.onload = function() {
          itemContainer.classList.add('loaded');
      };

      itemContainer.appendChild(img);
      return itemContainer;
    }

    /** 测试图片路径是否可访问 */
    function testImage(path) {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(true);
        img.onerror = () => resolve(false);
        img.src = path;
      });
    }

    /** 显示网络异常覆盖层 */
    function showOverlay(msg) {
      if (msg) els.msg.textContent = msg;
      els.overlay.classList.add('show');
    }

    /** 禁用页面保护功能 */
    function setupProtection() {
      document.oncontextmenu = document.ondragstart = () => false;
      window.onkeydown = (e) => {
        if ((e.ctrlKey || e.metaKey) && ['s','u','i'].includes(e.key.toLowerCase())) e.preventDefault();
      };
    }
  </script>
</body>
</html>
